#|

Source: https://github.com/NVIDIA/cuda-samples/blob/master/Samples/matrixMulDrv/matrixMul_kernel.cu

|#


shared C, A, B, As, Bs;
const
  local bx,
  local by,
  local tx,
  local ty,
  local b,
  global wA,
  global wB,
  global blockSize,
  global gridDim.x,
  global gridDym.y,
  global block_size,
where
  gridDim.x > 0 &&
  gridDim.y > 0 &&
  bx < gridDim.x &&
  by < gridDim.y &&
  # GPUVerify assumptions
  tx < blockSize &&
  ty < blockSize &&
  # Assumption
  distinct [tx][ty][bx][by] &&
  # GPUVerify assumptions
  gridDim.x == 20 &&
  gridDim.y == 10 &&
  (blockSize == 32 || blockSize == 64) &&
  #wA == 320;
  wA > 1 &&
  block_size > 0 &&
  wB > 1 &&
  wB == 640 &&
  wA == block_size * gridDim.y &&
  wB == block_size * gridDim.x &&
  true
  ;


# Assumptions
let aBegin = wA * block_size * by;
let aEnd = aBegin + wA - 1;
let aStep = block_size;
let bBegin = block_size * bx;
let bStep = block_size * wB;

foreach (a in aBegin .. aEnd + 1; a + aStep) {
    rw As[by][bx][ty][tx];
    rw Bs[by][bx][ty][tx];
    if (b >= bBegin && (b - bBegin) % bStep == 0 ) {
        ro A[a + wA * ty + tx];
        ro B[b + wB * ty + tx];
    }
    sync;
    foreach (k in 0.. block_size) {
        ro As[ty][k];
        ro Bs[k][tx];
    }
    sync;
}

if (tx < block_size && ty < block_size) {
  let c = wB * block_size * by + block_size * bx;
  let d = wB * ty + tx;
  rw C[c + d];
}
