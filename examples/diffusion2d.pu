shared
  f,
  fn,
;
const
  global nx,
  global ny,
  global blockDim.x,
  global blockDim.y,
  local blockIdx.x,
  local blockIdx.y,
  local threadIdx.x,
  local threadIdx.y,
  local j,
  local jx,
  local jy,
where
  distinct [blockIdx.x][blockIdx.y][threadIdx.x][threadIdx.y] &&
  threadIdx.x < blockDim.x &&
  threadIdx.y < blockDim.y &&
  blockDim.x > 0 &&
  blockDim.y > 0
;

# XXX: prove without this
let blockDim.x = 512;
# XXX: prove without this
let blockDim.y = 512;

let nx = blockDim.x; # * gridDim.x;
let ny = blockDim.y; # * gridDim.y;


let jy = blockDim.y*blockIdx.y + threadIdx.y;
let jx = blockDim.x*blockIdx.x + threadIdx.x;

#assert distinct [jx][jy];

let j = nx*jy + jx;

if (nx > 0 && ny > 0 && jx < ny && jy < ny) {
  ro f[j];
  if (jx != 0) ro f[j - 1];
  if (jx != nx - 1) ro f[j+1];
  if (jy != 0) ro f[j-nx];
  if (jy != ny - 1) ro f[j+nx];
  rw fn[j];
}