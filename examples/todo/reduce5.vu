shared g_idata, g_odata, sdata, A;

const
  local threadIdx.x,
  global blockDim.x,
  local blockIdx.x,
  local tid,
  local i,
  global blockSize;

assert threadIdx.x < blockDim.x;
assert i == blockIdx.x*(blockDim.x*2)+ threadIdx.x;
assert distinct [blockIdx.x][threadIdx.x];
prove distinct[i];

assert tid == threadIdx.x;

ro g_idata[i];
ro g_idata[i + blockDim.x];
rw sdata[blockIdx.x][tid];
sync;

foreach s < blockDim.x {
  assert pow2(s) && s > 32;
  ro sdata[blockIdx.x][tid + s] if tid < blockDim.x;
  rw sdata[blockIdx.x][tid] if tid < blockDim.x;
  sync;
}

rw A[blockIdx.x][tid];
rw A[blockIdx.x][tid + 1];
#rw sdata[blockIdx.x][tid + 1];
#rw sdata[blockIdx.x][tid];

#ro sdata[blockIdx.x][tid + 1] ; #if (blockSize >=  64);
#rw sdata[blockIdx.x][tid]; # if (blockSize >= 64);
# sdata[tid] += sdata[tid + 32];if (blockSize >=  32) sdata[tid] += sdata[tid + 16];if (blockSize >=  16) sdata[tid] += sdata[tid +  8];if(blockSize >=   8) sdata[tid] += sdata[tid +  4];if (blockSize >=   4) sdata[tid] += sdata[tid +  2];if (blockSize >=   2) sdata[tid] += sdata[tid +  1]

ro sdata[0] if tid == 0;
rw g_odata[blockIdx.x] if tid == 0;
